{"version":3,"sources":["logo.svg","store.js","sketch1.js","sketch2.js","sketch3.js","sketch3top.js","sketch3left.js","sketch3front.js","P5Wrapper.js","HomePage.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","__webpack_require__","p","appStates","defaultState","grid","maze","appState","name","index","handlers","_handlers","Object","defineProperty","state","action","stateIndex","length","objectSpread","store","createStore","arguments","undefined","hasOwnProperty","type","sketch1","s","cam","initialOffset","Math","floor","cubeSize","setup","createCanvas","WEBGL","createCamera","setPosition","draw","lookAt","background","orbitControl","translate","stroke","fill","i","j","k","box","sketch2","totalSize","Cube","xIndex","yIndex","zIndex","classCallCheck","this","value","x","y","z","previousCube","createClass","key","inMaze","wallsToCheck","continueDrawing","hasStateProgressed","startingPoint","push","randIndex","random","currentWall","currentCube","node","opposingCubeX","opposingCubeY","opposingCubeZ","getOpposingCube","includes","neighbors","getNeighbors","forEach","newCube","splice","noStroke","arr1","arr2","el","show","cell","dispatch","sketch3","props","g","Infinity","getDistance","currentNode","goalNode","hypot","isBlockInside","current","elt","depth","inverseDepth","hasGridBeenMade","temp","intervalId","setInterval","stepForward","goal","mazeNeighbors","tempG","openSet","closedSet","continueSearching","pathMade","finalPath","cubeDepth","propsGrid","newGrid","createGrid","propsMaze","myGrid","newMaze","mazeElt","toAddToMaze","createMaze","myMaze","_","flattenDeep","filter","centers","centerIndex","getGoal","f","reduce","a","b","clearInterval","arr","removeFromArray","myNeighbors","potentialNeighbors","getMazeNeighbors","neighborNode","min","currentPath","item","sketch3top","sketch3left","sketch3front","P5Wrapper","canvas1","window","p5","nextProps","remove","canvas3","canvasLeft","canvasTop","canvasFront","react_default","createElement","id","Component","connect","progressState","buttonTexts","HomePage","possibleConstructorReturn","getPrototypeOf","call","buttonActivation","buttonText","disabled","onClick","src_P5Wrapper","className","React","App","src_HomePage","Boolean","location","hostname","match","ReactDOM","render","es","src_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.a1e84740.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import {createStore} from 'redux';\n\nlet appStates = ['pre-generate', 'generating', 'pre-solve', 'solving', 'done']\nlet buttonTexts = ['Generate Maze', '(Generating)', 'Solve Maze', '(Solving)', 'Restart']\n\n\n\nconst PROGRESS_STATE = 'PROGRESS_STATE'\nconst UPDATE_GRID = 'UPDATE_GRID'\nconst UPDATE_MAZE = 'UPDATE_MAZE'\n\nconst defaultState = {\n  grid: [[[]]],\n  maze: [],\n  appState: {name: appStates[0], index: 0}\n}\n\n// const SET_SELECTED_CAMPUS = 'SET_SELECTED_CAMPUS';\n// export const setSelectedCampus = (campus) => ({\n//   type: SET_SELECTED_CAMPUS,\n//   campus\n// });\n\n// export const fetchSingleCampus = (campusId) => {\n//   return async (dispatch) => {\n//     try {\n//       const singleCampusResponse = await axios.get(`/api/campuses/${campusId}`);\n//       dispatch(setSelectedCampus(singleCampusResponse.data))\n//     } catch (error) {\n//       console.log('failed to retrieve single campus data in fetchSingleCampus thunk');\n//       console.log(error);\n//     }\n//   }\n// };\n\nexport const progressState = () => {\n  return {\n    type: PROGRESS_STATE\n  }\n}\n\nexport const updateGrid = (newGrid) => {\n  return {\n    type: UPDATE_GRID,\n    grid: newGrid\n  }\n}\n\nexport const updateMaze = (newMaze) => {\n  return {\n    type: UPDATE_MAZE,\n    maze: newMaze\n  }\n}\n\n\nconst handlers = {\n  // [HANLDER_NAME]: (state, action) => {\n  //   return action.whatever\n  // }\n  \n  [PROGRESS_STATE]: (state, action) => {\n    let stateIndex = state.appState.index;\n    stateIndex++;\n    if (stateIndex >= appStates.length) {\n      stateIndex = 0;\n    }\n    return {...state, appState: {name: appStates[stateIndex], index: stateIndex}}\n  },\n  \n  [UPDATE_GRID]: (state, action) => {\n    return {...state, grid: action.grid}\n  },\n  \n  [UPDATE_MAZE]: (state, action) => {\n    return {...state, maze: action.maze}\n  }\n  \n}\n\n\nconst reducer = (state = defaultState, action) => {\n  if (handlers.hasOwnProperty(action.type)) {\n    return handlers[action.type](state, action);\n  } else {\n    return state;\n  }\n}\n\n\nconst store = createStore(reducer);\n\n\nexport default store;\n","export default function (s) {\n\nlet size = 50;\nlet cubeSize = 9;\nlet cubeOffset = 0;\nlet initialOffset = Math.floor(cubeSize / 2) * (size + cubeOffset);\nlet cam;\n\ns.setup = function() {\n  s.createCanvas(500, 500, s.WEBGL);\n  cam = s.createCamera();\n  cam.setPosition(0, 0, initialOffset * 5)\n}\n\n\n\ns.draw = function() {\n\n  // default controls\n  cam.lookAt(0, 0, 0)\n  s.background(225);\n  s.orbitControl();\n  \n  // draws sets initial position and settings\n  // fill(0, 0, 0, 20)\n  // box(size * cubeSize + cubeSize * cubeOffset);\n  \n\n  \n  s.translate(-initialOffset, -initialOffset, -initialOffset);\n  s.stroke(0, 0, 0, 100);\n  // s.noStroke();\n\n  \n  \n  s.fill(0, 0, 0, 100);\n  \n  // draws all the boxes\n  for (let i = 0; i < cubeSize; i++) {\n    for (let j = 0; j < cubeSize; j++) {\n      for (let k = 0; k < cubeSize; k++) {\n        \n        s.translate(i * (size + cubeOffset), j * (size + cubeOffset), k * (size + cubeOffset));\n        \n        s.box(size, size, size);\n        \n        s.translate(-1 * i * (size + cubeOffset), -1 * j * (size + cubeOffset), -1 * k * (size + cubeOffset));\n      }\n    }\n  }\n  \n  \n  // makes random boxes highlight for testing\n  // s.fill(255, 0, 0);\n  // let rand1 = Math.floor(Math.random()*cubeSize);\n  // let rand2 = Math.floor(Math.random()*cubeSize);\n  // let rand3 = Math.floor(Math.random()*cubeSize);\n  \n  // s.translate(rand1 * (size + cubeOffset) , rand2 * (size + cubeOffset), rand3 * (size + cubeOffset))\n  // s.box(size, size, size);\n  // s.translate(-rand1 * (size + cubeOffset), -rand2 * (size + cubeOffset), -rand3 * (size + cubeOffset));\n\n  \n}\n\n}\n","import store, {progressState, updateGrid, updateMaze} from './store'\nexport default function (s) {\n  \n  \nlet cubeSize = 50;\nlet totalSize = 9;\nlet cubeOffset = 0;\nlet initialOffset = Math.floor(totalSize / 2) * (cubeSize + cubeOffset);\nlet cam;\n\n\nfunction getNeighbors(node) {\n  let neighbors = [];\n  let x = node.xIndex;\n  let y = node.yIndex;\n  let z = node.zIndex;\n  \n  if (x < totalSize - 1) {\n    neighbors.push(grid[x+1][y][z])\n  }\n  if (x > 0) {\n    neighbors.push(grid[x-1][y][z])\n  }\n  if (y < totalSize - 1) {\n    neighbors.push(grid[x][y+1][z])\n  }\n  if (y > 0) {\n    neighbors.push(grid[x][y-1][z])\n  }\n  if (z < totalSize - 1) {\n    neighbors.push(grid[x][y][z+1])\n  }\n  if (z > 0) {\n    neighbors.push(grid[x][y][z-1])\n  }\n  \n  return neighbors\n}\n\nfunction getOpposingCube(node) {\n  \n  let opposingCubeX = (2 * node.xIndex - node.previousCube.xIndex);\n  let opposingCubeY = (2 * node.yIndex - node.previousCube.yIndex);\n  let opposingCubeZ = (2 * node.zIndex - node.previousCube.zIndex);\n  \n  \n  if (opposingCubeX < totalSize && opposingCubeY < totalSize && opposingCubeZ < totalSize && opposingCubeX >= 0 && opposingCubeY >= 0 && opposingCubeZ >= 0) {\n    let opposingCube = grid[opposingCubeX][opposingCubeY][opposingCubeZ]\n    return opposingCube;\n  }\n  return null;\n}\n\n\nlet Cube = class {\n  constructor(xIndex, yIndex, zIndex) {\n    this.value = false;\n    this.xIndex = xIndex;\n    this.yIndex = yIndex;\n    this.zIndex = zIndex;\n    this.x = xIndex * cubeSize;\n    this.y = yIndex * cubeSize;\n    this.z = zIndex * cubeSize;\n    this.previousCube = null;\n  }\n  \n  show() {\n\n    s.translate(this.xIndex * (cubeSize + cubeOffset), this.yIndex * (cubeSize + cubeOffset), this.zIndex * (cubeSize + cubeOffset));\n        \n    s.box(cubeSize, cubeSize, cubeSize);\n    s.translate(-1 * this.xIndex * (cubeSize + cubeOffset), -1 * this.yIndex * (cubeSize + cubeOffset), -1 * this.zIndex * (cubeSize + cubeOffset));\n  }\n  \n}\n\nlet grid = [];\n\nfor (let i = 0; i < totalSize; i++) {\n  grid[i] = [];\n  for (let j = 0; j < totalSize; j++) {\n    grid[i][j] = []\n    for (let k = 0; k < totalSize; k++) {\n      grid[i][j][k] = new Cube(i, j, k);\n    }\n  }\n}\n\nlet inMaze = [];\nlet wallsToCheck = [];\nlet continueDrawing = true;\nlet hasStateProgressed = false;\n\ns.setup = function() {\n  s.createCanvas(500, 500, s.WEBGL);\n  cam = s.createCamera();\n  cam.setPosition(0, 0, initialOffset * 5)\n  // frameRate(5);\n  \n  // initial maze setup\n  let startingPoint = grid[0][0][0];\n  startingPoint.value = true;\n  inMaze.push(startingPoint);\n  \n  // add neighbors to wallstocheck\n  grid[0][0][1].previousCube = startingPoint;\n  grid[0][1][0].previousCube = startingPoint;\n  grid[1][0][0].previousCube = startingPoint;\n  wallsToCheck.push(grid[1][0][0]);\n  wallsToCheck.push(grid[0][1][0]);\n  wallsToCheck.push(grid[0][0][1]);\n}\n\n\ns.draw = function() {\n\n  // default controls\n  cam.lookAt(0, 0, 0)\n  s.background(225);\n  s.orbitControl();\n  \n  // bix cube that encompasses all cubes\n  // fill(0, 0, 0, 20)\n  // box(cubeSize * totalSize + totalSize * cubeOffset);\n  \n  if (continueDrawing) {\n  \n  let randIndex = Math.floor(Math.random() * wallsToCheck.length);\n  \n  let currentWall = wallsToCheck[randIndex]\n  let currentCube = getOpposingCube(currentWall);\n  \n  if (!inMaze.includes(currentCube) && currentCube !== null) {\n    currentWall.value = true;\n    currentCube.value = true;\n    inMaze.push(currentWall);\n    inMaze.push(currentCube);\n    \n    \n\n    let newNeighbors = getNeighbors(currentCube);\n    \n    newNeighbors.forEach((newCube) => {\n      if (!inMaze.includes(newCube)) {\n        if (!wallsToCheck.includes(newCube)) {\n          newCube.previousCube = currentCube;\n          wallsToCheck.push(newCube);\n        }\n      }\n    })\n    \n    \n  }\n  wallsToCheck.splice(randIndex, 1);\n  \n  }\n  \n  // draw stuff\n  \n  s.translate(-initialOffset, -initialOffset, -initialOffset);\n  s.stroke(0);\n  s.noStroke();\n  \n  grid.forEach((arr1) => {\n    arr1.forEach((arr2) => {\n      arr2.forEach((el) => {\n        s.fill(0, 0, 0, 150);\n        el.show();\n        \n      })\n    })\n  })\n\n  \n  inMaze.forEach((cell) => {\n    s.fill(255, 255, 0, 80);\n    cell.show();\n    \n  })\n  \n  wallsToCheck.forEach((cell) => {\n    s.stroke(0)\n    s.fill(0, 0, 255, 20) \n    cell.show();\n    s.noStroke()\n  })\n  \n  if (!wallsToCheck.length) {\n    continueDrawing = false;\n    // update grid on state\n    // update app state so button is clickable\n    \n    if (!hasStateProgressed) {\n      hasStateProgressed = true;\n      store.dispatch(progressState())\n      store.dispatch(updateGrid(grid))\n      store.dispatch(updateMaze(inMaze))\n    }\n    \n  }\n  \n  \n  // makes random boxes highlight for testing\n  // fill(255, 0, 0);\n  // let rand1 = Math.floor(Math.random()*totalSize);\n  // let rand2 = Math.floor(Math.random()*totalSize);\n  // let rand3 = Math.floor(Math.random()*totalSize);\n  \n  // translate(rand1 * (cubeSize + cubeOffset) , rand2 * (cubeSize + cubeOffset), rand3 * (cubeSize + cubeOffset))\n  // box(cubeSize, cubeSize, cubeSize);\n  // translate(-rand1 * (cubeSize + cubeOffset), -rand2 * (cubeSize + cubeOffset), -rand3 * (cubeSize + cubeOffset));\n  \n  \n}\n\n}\n\n\n","import store, { progressState, updateGrid, updateMaze } from './store'\nimport _ from 'lodash'\n\nexport default function (s) {\n\n  s.props = { grid: [] }\n\n\n  let cubeSize = 50;\n  let totalSize = 9;\n  let cubeOffset = 0;\n  let initialOffset = Math.floor(totalSize / 2) * (cubeSize + cubeOffset);\n  let cam;\n\n\n\n  let Cube = class {\n    constructor(xIndex, yIndex, zIndex) {\n      this.value = false;\n      this.xIndex = xIndex;\n      this.yIndex = yIndex;\n      this.zIndex = zIndex;\n      this.x = xIndex * cubeSize;\n      this.y = yIndex * cubeSize;\n      this.z = zIndex * cubeSize;\n      this.previousCube = null;\n      this.g = Infinity;\n    }\n\n    show() {\n\n      s.translate(this.xIndex * (cubeSize + cubeOffset), this.yIndex * (cubeSize + cubeOffset), this.zIndex * (cubeSize + cubeOffset));\n\n      s.box(cubeSize, cubeSize, cubeSize);\n      s.translate(-1 * this.xIndex * (cubeSize + cubeOffset), -1 * this.yIndex * (cubeSize + cubeOffset), -1 * this.zIndex * (cubeSize + cubeOffset));\n    }\n\n  }\n\n\n\n  function createGrid(propsGrid) {\n    let newGrid = [];\n    for (let i = 0; i < propsGrid.length; i++) {\n      newGrid[i] = [];\n      for (let j = 0; j < propsGrid.length; j++) {\n        newGrid[i][j] = [];\n        for (let k = 0; k < propsGrid.length; k++) {\n          newGrid[i][j][k] = new Cube(i, j, k)\n        }\n      }\n    }\n\n    return newGrid;\n  }\n\n  function createMaze(propsMaze, myGrid) {\n    let newMaze = [];\n    propsMaze.forEach((mazeElt) => {\n      let toAddToMaze = myGrid[mazeElt.xIndex][mazeElt.yIndex][mazeElt.zIndex]\n      newMaze.push(toAddToMaze);\n    })\n\n    return newMaze;\n  }\n\n  function getWalls(myGrid, myMaze) {\n    let spreadGrid = _.flattenDeep(myGrid);\n    let getWalls = spreadGrid.filter((elt) => {\n      return !myMaze.includes(elt)\n    })\n    return getWalls;\n  }\n\n  function getGoal(myGrid, myMaze) {\n    let centers = []\n    let potentialGoals = []\n    \n    if (myGrid.length%2===0) {\n      // is even\n      let centerIndex = myGrid.length/2;\n      centers.push(myGrid[centerIndex-1][centerIndex-1][centerIndex-1])\n      centers.push(myGrid[centerIndex-1][centerIndex-1][centerIndex])\n      centers.push(myGrid[centerIndex-1][centerIndex][centerIndex-1])\n      centers.push(myGrid[centerIndex-1][centerIndex][centerIndex])\n      centers.push(myGrid[centerIndex][centerIndex-1][centerIndex-1])\n      centers.push(myGrid[centerIndex][centerIndex-1][centerIndex])\n      centers.push(myGrid[centerIndex][centerIndex][centerIndex-1])\n      centers.push(myGrid[centerIndex][centerIndex][centerIndex])\n      \n    } else {\n      // is odd\n      let centerIndex = Math.floor(myGrid.length/2);\n      \n      for (let i = centerIndex-1; i <= centerIndex + 1; i++) {\n        for (let j = centerIndex-1; j <= centerIndex + 1; j++) {\n          for (let k = centerIndex-1; k <= centerIndex + 1; k++) {\n            centers.push(myGrid[i][j][k])\n          }\n        }\n      }\n    }\n    \n    potentialGoals = centers.filter((elt) => {\n      return myMaze.includes(elt);\n    })\n    \n    let myGoal = potentialGoals[0]\n    return myGoal;\n  }\n  \n  \n  function getDistance(currentNode, goalNode) {\n    return Math.hypot((currentNode.xIndex-goalNode.xIndex), (currentNode.yIndex-goalNode.yIndex), (currentNode.zIndex-goalNode.zIndex))\n    \n  }\n  \n  \n  function removeFromArray(arr, elt) {\n    for (let i = arr.length - 1; i >= 0; i--) {\n      if (arr[i] === elt) {\n        arr.splice(i, 1);\n      }\n    }\n  };\n  \n  \n\n  function getNeighbors(node) {\n    let myNeighbors = [];\n    let x = node.xIndex;\n    let y = node.yIndex;\n    let z = node.zIndex;\n    \n    if (x < totalSize - 1) {\n      myNeighbors.push(grid[x + 1][y][z])\n    }\n    if (x > 0) {\n      myNeighbors.push(grid[x - 1][y][z])\n    }\n    if (y < totalSize - 1) {\n      myNeighbors.push(grid[x][y + 1][z])\n    }\n    if (y > 0) {\n      myNeighbors.push(grid[x][y - 1][z])\n    }\n    if (z < totalSize - 1) {\n      myNeighbors.push(grid[x][y][z + 1])\n    }\n    if (z > 0) {\n      myNeighbors.push(grid[x][y][z - 1])\n    }\n\n    return myNeighbors\n  }\n  \n  function getMazeNeighbors(potentialNeighbors, myMaze) {\n    \n    let myMazeNeighbors = potentialNeighbors.filter((node) => {\n      return myMaze.includes(node);\n    })\n    \n    return myMazeNeighbors;\n    \n  }\n  \n  \n  function isBlockInside(current, elt, depth) {\n    if (!current) {\n      return true;\n    }\n    if (elt.xIndex < depth || elt.yIndex < depth || elt.zIndex < depth) {\n      return false\n    }\n    let inverseDepth = grid.length - depth;\n    if (elt.xIndex > inverseDepth || elt.yIndex > inverseDepth || elt.zIndex > inverseDepth) {\n      return false;\n    }\n    return true;\n    \n    \n  }\n\n\n  let grid = [[[]]];\n  let maze = [];\n  let mazeWalls = [];\n  let inMaze = [];\n  let wallsToCheck = [];\n  let continueDrawing = true;\n  let hasStateProgressed = false;\n  let hasGridBeenMade;\nlet temp;\n  \n  s.setup = function () {\n    s.createCanvas(500, 500, s.WEBGL);\n    cam = s.createCamera();\n    cam.setPosition(0, 0, initialOffset * 5)\n    // frameRate(5);\n\n    hasGridBeenMade = false;\n    intervalId = setInterval(() => {\n      stepForward = !stepForward;\n    }, 500)\n\n\n    // // initial maze setup\n    // let startingPoint = grid[0][0][0];\n    // startingPoint.value = true;\n    // inMaze.push(startingPoint);\n\n    // // add neighbors to wallstocheck\n    // grid[0][0][1].previousCube = startingPoint;\n    // grid[0][1][0].previousCube = startingPoint;\n    // grid[1][0][0].previousCube = startingPoint;\n    // wallsToCheck.push(grid[1][0][0]);\n    // wallsToCheck.push(grid[0][1][0]);\n    // wallsToCheck.push(grid[0][0][1]);\n  }\n\n\n  let openSet = []\n  let closedSet = []\n  let continueSearching = true;\n  let current;\n  let goal;\n  let mazeNeighbors;\n  let neighbors;\n  let tempG;\n  let pathMade = false;\n  let finalPath = [];\n  let stepForward = true;\n  let intervalId;\n  let cubeDepth = 0;\n  \n  s.draw = function () {\n\n\n    \n    if (!hasGridBeenMade && s.props.grid.length) {\n      // necessary sets are created once props come in\n      // and starting box is set/placed into open set.\n      // ending box is also determined and placed as the goal node\n      grid = createGrid(s.props.grid);\n      maze = createMaze(s.props.maze, grid);\n      mazeWalls = getWalls(grid, maze);\n      \n      goal = getGoal(grid, maze);\n      \n      let startingPoint = grid[0][0][0]\n      startingPoint.g = 0;\n      startingPoint.f = getDistance(startingPoint, goal);\n      openSet.push(startingPoint)\n      hasGridBeenMade = true;\n    } else {\n      \n      if (stepForward) {\n        stepForward = !stepForward;\n      \n      \n      \n      if (continueSearching && openSet.length) {\n        // search algorighm logic here\n        \n        current = openSet.reduce((a, b) => {\n          return (a.f < b.f ? a : b)\n        });\n        \n        if (current === goal) {\n          continueSearching = false;\n          clearInterval(intervalId);\n          store.dispatch(progressState())\n        }\n        \n        removeFromArray(openSet, current);\n        closedSet.push(current);\n        \n        // these next 2 functions obtain all of the neighbors of the current\n        // block, and then filters it so it is only the neighbors that are\n        // indeed part of the maze, and are not walls of the maze\n        neighbors = getNeighbors(current);\n        mazeNeighbors = getMazeNeighbors(neighbors, maze);\n        for (let i = 0; i < mazeNeighbors.length; i++) {\n          let neighborNode = mazeNeighbors[i]\n          \n          if (closedSet.includes(neighborNode)) {\n            continue;\n          }\n          \n          tempG = current.g + getDistance(current, neighborNode);\n          \n          if (!openSet.includes(neighborNode)) {\n            openSet.push(neighborNode);\n          } else if (tempG >= neighborNode.g) {\n            continue\n          }\n          \n          neighborNode.previousCube = current;\n          neighborNode.g = tempG;\n          neighborNode.f = neighborNode.g + getDistance(neighborNode, goal);\n          \n          \n        }\n      }\n      \n      \n      \n      \n      // if (openSet.length === 0) {\n      //   continueSearching = false;\n        // clearInterval(intervalId);\n      // }\n      \n    }\n\n      cam.lookAt(0, 0, 0)\n      s.background(225);\n      s.orbitControl();\n\n      // big cube that encompasses all cubes\n      // fill(0, 0, 0, 20)\n      // box(cubeSize * totalSize + totalSize * cubeOffset);\n\n\n\n      // draw stuff\n      s.translate(-initialOffset, -initialOffset, -initialOffset);\n      s.stroke(0);\n      s.noStroke();\n      \n      \n      \n      if (current) {\n        cubeDepth = Math.min(current.xIndex, current.yIndex, current.zIndex);\n      }\n      \n      \n      grid.forEach((arr1) => {\n        arr1.forEach((arr2) => {\n          arr2.forEach((el) => {\n            if (!maze.includes(el)) {\n            if (!isBlockInside(current, el, cubeDepth) && continueSearching) {\n              s.fill(0, 0, 0, 15)\n              el.show()\n            } else {\n              s.fill(0, 0, 0, 150);\n              el.show();\n              s.noStroke()\n              // s.fill(0, 0, 245);\n              // el.show();\n            }\n          }\n            \n          })\n        })\n      })\n      \n      \n      \n      maze.forEach((cell) => {\n        if (!isBlockInside(current, cell, cubeDepth) && continueSearching) {\n          s.fill(255, 255, 0, 5)\n          cell.show()\n        } else {\n          s.fill(255, 255, 0, 15);\n          cell.show();\n          // s.stroke(0);\n          // s.fill(255, 255, 0, 245);\n          // cell.show();\n          // s.noStroke();\n        }\n        \n        \n        // s.fill(255, 255, 0, 80);\n        // cell.show();\n      })\n\n      wallsToCheck.forEach((cell) => {\n        s.fill(0, 0, 255, 20)\n        cell.show();\n      })\n      \n      \n      \n      openSet.forEach((cell) => {\n        s.fill(0, 255, 0, 20);\n        cell.show();\n      })\n      \n      closedSet.forEach((cell) => {\n        s.fill(255, 0, 0, 20);\n        cell.show();\n      })\n      \n      if (goal) {\n        s.fill(255, 0, 255, 255);\n        goal.show();\n      }\n      \n      //\n      // display external blocks shallowly\n      // as head of search goes further into cube\n      \n      \n      \n      \n      s.stroke(0);\n      s.fill(0, 0, 255, 100);\n      if (current) {\n        current.show();\n      }\n      \n      \n      \n      \n      \n      if (!continueSearching) {\n        temp = current;\n        finalPath.push(temp);\n        while (temp.previousCube && !pathMade) {\n          finalPath.push(temp.previousCube);\n          temp = temp.previousCube;\n        }\n        pathMade = true;\n        finalPath.forEach((item) => {\n          s.noStroke();\n          s.fill(0, 0, 255, 100);\n          item.show()\n        })\n        \n      } else {\n          if (current) {\n          temp = current;\n          let currentPath = [];\n          currentPath.push(temp)\n          while (temp.previousCube) {\n          currentPath.push(temp.previousCube);\n            temp = temp.previousCube\n          }\n          s.fill(0, 0, 255, 50);\n          currentPath.forEach((item) => {\n            item.show();\n          })\n        }\n        \n      }\n      \n      \n    }\n  }\n\n}\n\n\n","import store, { progressState, updateGrid, updateMaze } from './store'\nimport _ from 'lodash'\n\nexport default function (s) {\n\n  s.props = { grid: [] }\n\n\n  let cubeSize = 50/3;\n  let totalSize = 9;\n  let cubeOffset = 0;\n  let initialOffset = Math.floor(totalSize / 2) * (cubeSize + cubeOffset);\n  let cam;\n\n\n\n  let Cube = class {\n    constructor(xIndex, yIndex, zIndex) {\n      this.value = false;\n      this.xIndex = xIndex;\n      this.yIndex = yIndex;\n      this.zIndex = zIndex;\n      this.x = xIndex * cubeSize;\n      this.y = yIndex * cubeSize;\n      this.z = zIndex * cubeSize;\n      this.previousCube = null;\n      this.g = Infinity;\n    }\n\n    show() {\n\n      s.translate(this.xIndex * (cubeSize + cubeOffset), this.yIndex * (cubeSize + cubeOffset), this.zIndex * (cubeSize + cubeOffset));\n\n      s.box(cubeSize, cubeSize, cubeSize);\n      s.translate(-1 * this.xIndex * (cubeSize + cubeOffset), -1 * this.yIndex * (cubeSize + cubeOffset), -1 * this.zIndex * (cubeSize + cubeOffset));\n    }\n\n  }\n\n\n\n  function createGrid(propsGrid) {\n    let newGrid = [];\n    for (let i = 0; i < propsGrid.length; i++) {\n      newGrid[i] = [];\n      for (let j = 0; j < propsGrid.length; j++) {\n        newGrid[i][j] = [];\n        for (let k = 0; k < propsGrid.length; k++) {\n          newGrid[i][j][k] = new Cube(i, j, k)\n        }\n      }\n    }\n\n    return newGrid;\n  }\n\n  function createMaze(propsMaze, myGrid) {\n    let newMaze = [];\n    propsMaze.forEach((mazeElt) => {\n      let toAddToMaze = myGrid[mazeElt.xIndex][mazeElt.yIndex][mazeElt.zIndex]\n      newMaze.push(toAddToMaze);\n    })\n\n    return newMaze;\n  }\n\n  function getWalls(myGrid, myMaze) {\n    let spreadGrid = _.flattenDeep(myGrid);\n    let getWalls = spreadGrid.filter((elt) => {\n      return !myMaze.includes(elt)\n    })\n    return getWalls;\n  }\n\n  function getGoal(myGrid, myMaze) {\n    let centers = []\n    let potentialGoals = []\n    \n    if (myGrid.length%2===0) {\n      // is even\n      let centerIndex = myGrid.length/2;\n      centers.push(myGrid[centerIndex-1][centerIndex-1][centerIndex-1])\n      centers.push(myGrid[centerIndex-1][centerIndex-1][centerIndex])\n      centers.push(myGrid[centerIndex-1][centerIndex][centerIndex-1])\n      centers.push(myGrid[centerIndex-1][centerIndex][centerIndex])\n      centers.push(myGrid[centerIndex][centerIndex-1][centerIndex-1])\n      centers.push(myGrid[centerIndex][centerIndex-1][centerIndex])\n      centers.push(myGrid[centerIndex][centerIndex][centerIndex-1])\n      centers.push(myGrid[centerIndex][centerIndex][centerIndex])\n      \n    } else {\n      // is odd\n      let centerIndex = Math.floor(myGrid.length/2);\n      \n      for (let i = centerIndex-1; i <= centerIndex + 1; i++) {\n        for (let j = centerIndex-1; j <= centerIndex + 1; j++) {\n          for (let k = centerIndex-1; k <= centerIndex + 1; k++) {\n            centers.push(myGrid[i][j][k])\n          }\n        }\n      }\n    }\n    \n    potentialGoals = centers.filter((elt) => {\n      return myMaze.includes(elt);\n    })\n    \n    let myGoal = potentialGoals[0]\n    return myGoal;\n  }\n  \n  \n  function getDistance(currentNode, goalNode) {\n    return Math.hypot((currentNode.xIndex-goalNode.xIndex), (currentNode.yIndex-goalNode.yIndex), (currentNode.zIndex-goalNode.zIndex))\n    \n  }\n  \n  \n  function removeFromArray(arr, elt) {\n    for (let i = arr.length - 1; i >= 0; i--) {\n      if (arr[i] === elt) {\n        arr.splice(i, 1);\n      }\n    }\n  };\n  \n  \n\n  function getNeighbors(node) {\n    let myNeighbors = [];\n    let x = node.xIndex;\n    let y = node.yIndex;\n    let z = node.zIndex;\n    \n    if (x < totalSize - 1) {\n      myNeighbors.push(grid[x + 1][y][z])\n    }\n    if (x > 0) {\n      myNeighbors.push(grid[x - 1][y][z])\n    }\n    if (y < totalSize - 1) {\n      myNeighbors.push(grid[x][y + 1][z])\n    }\n    if (y > 0) {\n      myNeighbors.push(grid[x][y - 1][z])\n    }\n    if (z < totalSize - 1) {\n      myNeighbors.push(grid[x][y][z + 1])\n    }\n    if (z > 0) {\n      myNeighbors.push(grid[x][y][z - 1])\n    }\n\n    return myNeighbors\n  }\n  \n  function getMazeNeighbors(potentialNeighbors, myMaze) {\n    \n    let myMazeNeighbors = potentialNeighbors.filter((node) => {\n      return myMaze.includes(node);\n    })\n    \n    return myMazeNeighbors;\n    \n  }\n  \n  \n  function isBlockInside(current, elt, depth) {\n    if (!current) {\n      return true;\n    }\n    if (elt.xIndex < depth || elt.yIndex < depth || elt.zIndex < depth) {\n      return false\n    }\n    let inverseDepth = grid.length - depth;\n    if (elt.xIndex > inverseDepth || elt.yIndex > inverseDepth || elt.zIndex > inverseDepth) {\n      return false;\n    }\n    return true;\n    \n    \n  }\n\n\n  let grid = [[[]]];\n  let maze = [];\n  let mazeWalls = [];\n  let inMaze = [];\n  let wallsToCheck = [];\n  let continueDrawing = true;\n  let hasStateProgressed = false;\n  let hasGridBeenMade;\nlet temp;\n  \n  s.setup = function () {\n    s.createCanvas(500/3, 500/3, s.WEBGL);\n    cam = s.createCamera();\n    cam.setPosition(0, 0, initialOffset * 4)\n    // frameRate(5);\n\n    hasGridBeenMade = false;\n    intervalId = setInterval(() => {\n      stepForward = !stepForward;\n    }, 500)\n    \n    \n    \n\n\n    // // initial maze setup\n    // let startingPoint = grid[0][0][0];\n    // startingPoint.value = true;\n    // inMaze.push(startingPoint);\n\n    // // add neighbors to wallstocheck\n    // grid[0][0][1].previousCube = startingPoint;\n    // grid[0][1][0].previousCube = startingPoint;\n    // grid[1][0][0].previousCube = startingPoint;\n    // wallsToCheck.push(grid[1][0][0]);\n    // wallsToCheck.push(grid[0][1][0]);\n    // wallsToCheck.push(grid[0][0][1]);\n  }\n\n\n  let openSet = []\n  let closedSet = []\n  let continueSearching = true;\n  let current;\n  let goal;\n  let mazeNeighbors;\n  let neighbors;\n  let tempG;\n  let pathMade = false;\n  let finalPath = [];\n  let stepForward = true;\n  let intervalId;\n  let cubeDepth = 0;\n  \n  s.draw = function () {\n\n\n    \n    if (!hasGridBeenMade && s.props.grid.length) {\n      // necessary sets are created once props come in\n      // and starting box is set/placed into open set.\n      // ending box is also determined and placed as the goal node\n      grid = createGrid(s.props.grid);\n      maze = createMaze(s.props.maze, grid);\n      mazeWalls = getWalls(grid, maze);\n      \n      goal = getGoal(grid, maze);\n      \n      let startingPoint = grid[0][0][0]\n      startingPoint.g = 0;\n      startingPoint.f = getDistance(startingPoint, goal);\n      openSet.push(startingPoint)\n      hasGridBeenMade = true;\n    } else {\n      \n      if (stepForward) {\n        stepForward = !stepForward;\n      \n      \n      \n      if (continueSearching && openSet.length) {\n        // search algorighm logic here\n        \n        current = openSet.reduce((a, b) => {\n          return (a.f < b.f ? a : b)\n        });\n        \n        if (current === goal) {\n          continueSearching = false;\n          clearInterval(intervalId);\n        }\n        \n        removeFromArray(openSet, current);\n        closedSet.push(current);\n        \n        // these next 2 functions obtain all of the neighbors of the current\n        // block, and then filters it so it is only the neighbors that are\n        // indeed part of the maze, and are not walls of the maze\n        neighbors = getNeighbors(current);\n        mazeNeighbors = getMazeNeighbors(neighbors, maze);\n        for (let i = 0; i < mazeNeighbors.length; i++) {\n          let neighborNode = mazeNeighbors[i]\n          \n          if (closedSet.includes(neighborNode)) {\n            continue;\n          }\n          \n          tempG = current.g + getDistance(current, neighborNode);\n          \n          if (!openSet.includes(neighborNode)) {\n            openSet.push(neighborNode);\n          } else if (tempG >= neighborNode.g) {\n            continue\n          }\n          \n          neighborNode.previousCube = current;\n          neighborNode.g = tempG;\n          neighborNode.f = neighborNode.g + getDistance(neighborNode, goal);\n          \n          \n        }\n      }\n      \n      \n      \n      \n      // if (openSet.length === 0) {\n      //   continueSearching = false;\n        // clearInterval(intervalId);\n      // }\n      \n    }\n      \n\n      cam.lookAt(0, 0, 0)\n      s.background(225);\n\n      // big cube that encompasses all cubes\n      // fill(0, 0, 0, 20)\n      // box(cubeSize * totalSize + totalSize * cubeOffset);\n\n\n\n      // draw stuff\n      s.translate(-initialOffset, -initialOffset, -initialOffset);\n      s.noStroke();\n      \n      \n      \n      if (current) {\n        cubeDepth = Math.min(current.xIndex, current.yIndex, current.zIndex);\n      }\n      \n      \n      grid.forEach((arr1) => {\n        arr1.forEach((arr2) => {\n          arr2.forEach((el) => {\n\n            if (!isBlockInside(current, el, cubeDepth) && continueSearching) {\n              s.fill(0, 0, 0, 15)\n              el.show()\n            } else {\n              s.fill(0, 0, 0, 150);\n              el.show();\n              s.noStroke()\n              // s.fill(0, 0, 245);\n              // el.show();\n            }\n            \n          })\n        })\n      })\n      \n      \n      \n      maze.forEach((cell) => {\n        if (!isBlockInside(current, cell, cubeDepth) && continueSearching) {\n          s.fill(255, 255, 0, 15)\n          cell.show()\n        } else {\n          s.fill(255, 255, 0, 80);\n          cell.show();\n          // s.stroke(0);\n          // s.fill(255, 255, 0, 245);\n          // cell.show();\n          // s.noStroke();\n        }\n        \n        \n        // s.fill(255, 255, 0, 80);\n        // cell.show();\n      })\n\n      wallsToCheck.forEach((cell) => {\n        s.fill(0, 0, 255, 20)\n        cell.show();\n      })\n      \n      \n      \n      openSet.forEach((cell) => {\n        s.fill(0, 255, 0, 20);\n        cell.show();\n      })\n      \n      closedSet.forEach((cell) => {\n        s.fill(255, 0, 0, 20);\n        cell.show();\n      })\n      \n      if (goal) {\n        s.fill(255, 0, 255, 255);\n        goal.show();\n      }\n      \n      //\n      // display external blocks shallowly\n      // as head of search goes further into cube\n      \n      \n      \n      \n      s.stroke(0);\n      s.fill(0, 0, 255, 255);\n      if (current) {\n        current.show();\n      }\n      \n      \n      \n      \n      \n      if (!continueSearching) {\n        temp = current;\n        finalPath.push(temp);\n        while (temp.previousCube && !pathMade) {\n          finalPath.push(temp.previousCube);\n          temp = temp.previousCube;\n        }\n        pathMade = true;\n        finalPath.forEach((item) => {\n          s.noStroke();\n          s.fill(0, 0, 255, 100);\n          item.show()\n        })\n        \n      } else {\n          if (current) {\n          temp = current;\n          let currentPath = [];\n          currentPath.push(temp)\n          while (temp.previousCube) {\n          currentPath.push(temp.previousCube);\n            temp = temp.previousCube\n          }\n          s.fill(0, 0, 255, 255);\n          currentPath.forEach((item) => {\n            item.show();\n          })\n        }\n        \n      }\n      \n      \n    }\n  }\n\n}\n\n\n","import store, { progressState, updateGrid, updateMaze } from './store'\nimport _ from 'lodash'\n\nexport default function (s) {\n\n  s.props = { grid: [] }\n\n\n  let cubeSize = 50/3;\n  let totalSize = 9;\n  let cubeOffset = 0;\n  let initialOffset = Math.floor(totalSize / 2) * (cubeSize + cubeOffset);\n  let cam;\n\n\n\n  let Cube = class {\n    constructor(xIndex, yIndex, zIndex) {\n      this.value = false;\n      this.xIndex = xIndex;\n      this.yIndex = yIndex;\n      this.zIndex = zIndex;\n      this.x = xIndex * cubeSize;\n      this.y = yIndex * cubeSize;\n      this.z = zIndex * cubeSize;\n      this.previousCube = null;\n      this.g = Infinity;\n    }\n\n    show() {\n\n      s.translate(this.xIndex * (cubeSize + cubeOffset), this.yIndex * (cubeSize + cubeOffset), this.zIndex * (cubeSize + cubeOffset));\n\n      s.box(cubeSize, cubeSize, cubeSize);\n      s.translate(-1 * this.xIndex * (cubeSize + cubeOffset), -1 * this.yIndex * (cubeSize + cubeOffset), -1 * this.zIndex * (cubeSize + cubeOffset));\n    }\n\n  }\n\n\n\n  function createGrid(propsGrid) {\n    let newGrid = [];\n    for (let i = 0; i < propsGrid.length; i++) {\n      newGrid[i] = [];\n      for (let j = 0; j < propsGrid.length; j++) {\n        newGrid[i][j] = [];\n        for (let k = 0; k < propsGrid.length; k++) {\n          newGrid[i][j][k] = new Cube(i, j, k)\n        }\n      }\n    }\n\n    return newGrid;\n  }\n\n  function createMaze(propsMaze, myGrid) {\n    let newMaze = [];\n    propsMaze.forEach((mazeElt) => {\n      let toAddToMaze = myGrid[mazeElt.xIndex][mazeElt.yIndex][mazeElt.zIndex]\n      newMaze.push(toAddToMaze);\n    })\n\n    return newMaze;\n  }\n\n  function getWalls(myGrid, myMaze) {\n    let spreadGrid = _.flattenDeep(myGrid);\n    let getWalls = spreadGrid.filter((elt) => {\n      return !myMaze.includes(elt)\n    })\n    return getWalls;\n  }\n\n  function getGoal(myGrid, myMaze) {\n    let centers = []\n    let potentialGoals = []\n    \n    if (myGrid.length%2===0) {\n      // is even\n      let centerIndex = myGrid.length/2;\n      centers.push(myGrid[centerIndex-1][centerIndex-1][centerIndex-1])\n      centers.push(myGrid[centerIndex-1][centerIndex-1][centerIndex])\n      centers.push(myGrid[centerIndex-1][centerIndex][centerIndex-1])\n      centers.push(myGrid[centerIndex-1][centerIndex][centerIndex])\n      centers.push(myGrid[centerIndex][centerIndex-1][centerIndex-1])\n      centers.push(myGrid[centerIndex][centerIndex-1][centerIndex])\n      centers.push(myGrid[centerIndex][centerIndex][centerIndex-1])\n      centers.push(myGrid[centerIndex][centerIndex][centerIndex])\n      \n    } else {\n      // is odd\n      let centerIndex = Math.floor(myGrid.length/2);\n      \n      for (let i = centerIndex-1; i <= centerIndex + 1; i++) {\n        for (let j = centerIndex-1; j <= centerIndex + 1; j++) {\n          for (let k = centerIndex-1; k <= centerIndex + 1; k++) {\n            centers.push(myGrid[i][j][k])\n          }\n        }\n      }\n    }\n    \n    potentialGoals = centers.filter((elt) => {\n      return myMaze.includes(elt);\n    })\n    \n    let myGoal = potentialGoals[0]\n    return myGoal;\n  }\n  \n  \n  function getDistance(currentNode, goalNode) {\n    return Math.hypot((currentNode.xIndex-goalNode.xIndex), (currentNode.yIndex-goalNode.yIndex), (currentNode.zIndex-goalNode.zIndex))\n    \n  }\n  \n  \n  function removeFromArray(arr, elt) {\n    for (let i = arr.length - 1; i >= 0; i--) {\n      if (arr[i] === elt) {\n        arr.splice(i, 1);\n      }\n    }\n  };\n  \n  \n\n  function getNeighbors(node) {\n    let myNeighbors = [];\n    let x = node.xIndex;\n    let y = node.yIndex;\n    let z = node.zIndex;\n    \n    if (x < totalSize - 1) {\n      myNeighbors.push(grid[x + 1][y][z])\n    }\n    if (x > 0) {\n      myNeighbors.push(grid[x - 1][y][z])\n    }\n    if (y < totalSize - 1) {\n      myNeighbors.push(grid[x][y + 1][z])\n    }\n    if (y > 0) {\n      myNeighbors.push(grid[x][y - 1][z])\n    }\n    if (z < totalSize - 1) {\n      myNeighbors.push(grid[x][y][z + 1])\n    }\n    if (z > 0) {\n      myNeighbors.push(grid[x][y][z - 1])\n    }\n\n    return myNeighbors\n  }\n  \n  function getMazeNeighbors(potentialNeighbors, myMaze) {\n    \n    let myMazeNeighbors = potentialNeighbors.filter((node) => {\n      return myMaze.includes(node);\n    })\n    \n    return myMazeNeighbors;\n    \n  }\n  \n  \n  function isBlockInside(current, elt, depth) {\n    if (!current) {\n      return true;\n    }\n    if (elt.xIndex < depth || elt.yIndex < depth || elt.zIndex < depth) {\n      return false\n    }\n    let inverseDepth = grid.length - depth;\n    if (elt.xIndex > inverseDepth || elt.yIndex > inverseDepth || elt.zIndex > inverseDepth) {\n      return false;\n    }\n    return true;\n    \n    \n  }\n\n\n  let grid = [[[]]];\n  let maze = [];\n  let mazeWalls = [];\n  let inMaze = [];\n  let wallsToCheck = [];\n  let continueDrawing = true;\n  let hasStateProgressed = false;\n  let hasGridBeenMade;\nlet temp;\n  \n  s.setup = function () {\n    s.createCanvas(500/3, 500/3, s.WEBGL);\n    cam = s.createCamera();\n    cam.setPosition(0, initialOffset * 4, 1)\n    // frameRate(5);\n\n    hasGridBeenMade = false;\n    intervalId = setInterval(() => {\n      stepForward = !stepForward;\n    }, 500)\n\n\n    // // initial maze setup\n    // let startingPoint = grid[0][0][0];\n    // startingPoint.value = true;\n    // inMaze.push(startingPoint);\n\n    // // add neighbors to wallstocheck\n    // grid[0][0][1].previousCube = startingPoint;\n    // grid[0][1][0].previousCube = startingPoint;\n    // grid[1][0][0].previousCube = startingPoint;\n    // wallsToCheck.push(grid[1][0][0]);\n    // wallsToCheck.push(grid[0][1][0]);\n    // wallsToCheck.push(grid[0][0][1]);\n  }\n\n\n  let openSet = []\n  let closedSet = []\n  let continueSearching = true;\n  let current;\n  let goal;\n  let mazeNeighbors;\n  let neighbors;\n  let tempG;\n  let pathMade = false;\n  let finalPath = [];\n  let stepForward = true;\n  let intervalId;\n  let cubeDepth = 0;\n  \n  s.draw = function () {\n\n\n    \n    if (!hasGridBeenMade && s.props.grid.length) {\n      // necessary sets are created once props come in\n      // and starting box is set/placed into open set.\n      // ending box is also determined and placed as the goal node\n      grid = createGrid(s.props.grid);\n      maze = createMaze(s.props.maze, grid);\n      mazeWalls = getWalls(grid, maze);\n      \n      goal = getGoal(grid, maze);\n      \n      let startingPoint = grid[0][0][0]\n      startingPoint.g = 0;\n      startingPoint.f = getDistance(startingPoint, goal);\n      openSet.push(startingPoint)\n      hasGridBeenMade = true;\n    } else {\n      \n      if (stepForward) {\n        stepForward = !stepForward;\n      \n      \n      \n      if (continueSearching && openSet.length) {\n        // search algorighm logic here\n        \n        current = openSet.reduce((a, b) => {\n          return (a.f < b.f ? a : b)\n        });\n        \n        if (current === goal) {\n          continueSearching = false;\n          clearInterval(intervalId);\n        }\n        \n        removeFromArray(openSet, current);\n        closedSet.push(current);\n        \n        // these next 2 functions obtain all of the neighbors of the current\n        // block, and then filters it so it is only the neighbors that are\n        // indeed part of the maze, and are not walls of the maze\n        neighbors = getNeighbors(current);\n        mazeNeighbors = getMazeNeighbors(neighbors, maze);\n        for (let i = 0; i < mazeNeighbors.length; i++) {\n          let neighborNode = mazeNeighbors[i]\n          \n          if (closedSet.includes(neighborNode)) {\n            continue;\n          }\n          \n          tempG = current.g + getDistance(current, neighborNode);\n          \n          if (!openSet.includes(neighborNode)) {\n            openSet.push(neighborNode);\n          } else if (tempG >= neighborNode.g) {\n            continue\n          }\n          \n          neighborNode.previousCube = current;\n          neighborNode.g = tempG;\n          neighborNode.f = neighborNode.g + getDistance(neighborNode, goal);\n          \n          \n        }\n      }\n      \n      \n      \n      \n      // if (openSet.length === 0) {\n      //   continueSearching = false;\n        // clearInterval(intervalId);\n      // }\n      \n    }\n\n      cam.lookAt(0, 0, 0)\n      s.background(225);\n\n      // big cube that encompasses all cubes\n      // fill(0, 0, 0, 20)\n      // box(cubeSize * totalSize + totalSize * cubeOffset);\n\n\n\n      // draw stuff\n      s.translate(-initialOffset, -initialOffset, -initialOffset);\n      s.noStroke();\n      \n      \n      \n      if (current) {\n        cubeDepth = Math.min(current.xIndex, current.yIndex, current.zIndex);\n      }\n      \n      \n      grid.forEach((arr1) => {\n        arr1.forEach((arr2) => {\n          arr2.forEach((el) => {\n\n            if (!isBlockInside(current, el, cubeDepth) && continueSearching) {\n              s.fill(0, 0, 0, 15)\n              el.show()\n            } else {\n              s.fill(0, 0, 0, 150);\n              el.show();\n              // s.fill(0, 0, 245);\n              // el.show();\n            }\n            \n          })\n        })\n      })\n      \n      \n      \n      maze.forEach((cell) => {\n        if (!isBlockInside(current, cell, cubeDepth) && continueSearching) {\n          s.fill(255, 255, 0, 15)\n          cell.show()\n        } else {\n          s.fill(255, 255, 0, 80);\n          cell.show();\n          // s.stroke(0);\n          // s.fill(255, 255, 0, 245);\n          // cell.show();\n          // s.noStroke();\n        }\n        \n        \n        // s.fill(255, 255, 0, 80);\n        // cell.show();\n      })\n\n      wallsToCheck.forEach((cell) => {\n        s.fill(0, 0, 255, 20)\n        cell.show();\n      })\n      \n      \n      \n      openSet.forEach((cell) => {\n        s.fill(0, 255, 0, 20);\n        cell.show();\n      })\n      \n      closedSet.forEach((cell) => {\n        s.fill(255, 0, 0, 20);\n        cell.show();\n      })\n      \n      if (goal) {\n        s.fill(255, 0, 255, 255);\n        goal.show();\n      }\n      \n      //\n      // display external blocks shallowly\n      // as head of search goes further into cube\n      \n      \n      \n      \n      s.stroke(0);\n      s.fill(0, 0, 255, 255);\n      if (current) {\n        current.show();\n      }\n      \n      \n      \n      \n      \n      if (!continueSearching) {\n        temp = current;\n        finalPath.push(temp);\n        while (temp.previousCube && !pathMade) {\n          finalPath.push(temp.previousCube);\n          temp = temp.previousCube;\n        }\n        pathMade = true;\n        finalPath.forEach((item) => {\n          s.noStroke();\n          s.fill(0, 0, 255, 100);\n          item.show()\n        })\n        \n      } else {\n          if (current) {\n          temp = current;\n          let currentPath = [];\n          currentPath.push(temp)\n          while (temp.previousCube) {\n          currentPath.push(temp.previousCube);\n            temp = temp.previousCube\n          }\n          s.fill(0, 0, 255, 255);\n          currentPath.forEach((item) => {\n            item.show();\n          })\n        }\n        \n      }\n      \n      \n    }\n  }\n\n}\n\n\n","import store, { progressState, updateGrid, updateMaze } from './store'\nimport _ from 'lodash'\n\nexport default function (s) {\n\n  s.props = { grid: [] }\n\n\n  let cubeSize = 50/3;\n  let totalSize = 9;\n  let cubeOffset = 0;\n  let initialOffset = Math.floor(totalSize / 2) * (cubeSize + cubeOffset);\n  let cam;\n\n\n\n  let Cube = class {\n    constructor(xIndex, yIndex, zIndex) {\n      this.value = false;\n      this.xIndex = xIndex;\n      this.yIndex = yIndex;\n      this.zIndex = zIndex;\n      this.x = xIndex * cubeSize;\n      this.y = yIndex * cubeSize;\n      this.z = zIndex * cubeSize;\n      this.previousCube = null;\n      this.g = Infinity;\n    }\n\n    show() {\n\n      s.translate(this.xIndex * (cubeSize + cubeOffset), this.yIndex * (cubeSize + cubeOffset), this.zIndex * (cubeSize + cubeOffset));\n\n      s.box(cubeSize, cubeSize, cubeSize);\n      s.translate(-1 * this.xIndex * (cubeSize + cubeOffset), -1 * this.yIndex * (cubeSize + cubeOffset), -1 * this.zIndex * (cubeSize + cubeOffset));\n    }\n\n  }\n\n\n\n  function createGrid(propsGrid) {\n    let newGrid = [];\n    for (let i = 0; i < propsGrid.length; i++) {\n      newGrid[i] = [];\n      for (let j = 0; j < propsGrid.length; j++) {\n        newGrid[i][j] = [];\n        for (let k = 0; k < propsGrid.length; k++) {\n          newGrid[i][j][k] = new Cube(i, j, k)\n        }\n      }\n    }\n\n    return newGrid;\n  }\n\n  function createMaze(propsMaze, myGrid) {\n    let newMaze = [];\n    propsMaze.forEach((mazeElt) => {\n      let toAddToMaze = myGrid[mazeElt.xIndex][mazeElt.yIndex][mazeElt.zIndex]\n      newMaze.push(toAddToMaze);\n    })\n\n    return newMaze;\n  }\n\n  function getWalls(myGrid, myMaze) {\n    let spreadGrid = _.flattenDeep(myGrid);\n    let getWalls = spreadGrid.filter((elt) => {\n      return !myMaze.includes(elt)\n    })\n    return getWalls;\n  }\n\n  function getGoal(myGrid, myMaze) {\n    let centers = []\n    let potentialGoals = []\n    \n    if (myGrid.length%2===0) {\n      // is even\n      let centerIndex = myGrid.length/2;\n      centers.push(myGrid[centerIndex-1][centerIndex-1][centerIndex-1])\n      centers.push(myGrid[centerIndex-1][centerIndex-1][centerIndex])\n      centers.push(myGrid[centerIndex-1][centerIndex][centerIndex-1])\n      centers.push(myGrid[centerIndex-1][centerIndex][centerIndex])\n      centers.push(myGrid[centerIndex][centerIndex-1][centerIndex-1])\n      centers.push(myGrid[centerIndex][centerIndex-1][centerIndex])\n      centers.push(myGrid[centerIndex][centerIndex][centerIndex-1])\n      centers.push(myGrid[centerIndex][centerIndex][centerIndex])\n      \n    } else {\n      // is odd\n      let centerIndex = Math.floor(myGrid.length/2);\n      \n      for (let i = centerIndex-1; i <= centerIndex + 1; i++) {\n        for (let j = centerIndex-1; j <= centerIndex + 1; j++) {\n          for (let k = centerIndex-1; k <= centerIndex + 1; k++) {\n            centers.push(myGrid[i][j][k])\n          }\n        }\n      }\n    }\n    \n    potentialGoals = centers.filter((elt) => {\n      return myMaze.includes(elt);\n    })\n    \n    let myGoal = potentialGoals[0]\n    return myGoal;\n  }\n  \n  \n  function getDistance(currentNode, goalNode) {\n    return Math.hypot((currentNode.xIndex-goalNode.xIndex), (currentNode.yIndex-goalNode.yIndex), (currentNode.zIndex-goalNode.zIndex))\n    \n  }\n  \n  \n  function removeFromArray(arr, elt) {\n    for (let i = arr.length - 1; i >= 0; i--) {\n      if (arr[i] === elt) {\n        arr.splice(i, 1);\n      }\n    }\n  };\n  \n  \n\n  function getNeighbors(node) {\n    let myNeighbors = [];\n    let x = node.xIndex;\n    let y = node.yIndex;\n    let z = node.zIndex;\n    \n    if (x < totalSize - 1) {\n      myNeighbors.push(grid[x + 1][y][z])\n    }\n    if (x > 0) {\n      myNeighbors.push(grid[x - 1][y][z])\n    }\n    if (y < totalSize - 1) {\n      myNeighbors.push(grid[x][y + 1][z])\n    }\n    if (y > 0) {\n      myNeighbors.push(grid[x][y - 1][z])\n    }\n    if (z < totalSize - 1) {\n      myNeighbors.push(grid[x][y][z + 1])\n    }\n    if (z > 0) {\n      myNeighbors.push(grid[x][y][z - 1])\n    }\n\n    return myNeighbors\n  }\n  \n  function getMazeNeighbors(potentialNeighbors, myMaze) {\n    \n    let myMazeNeighbors = potentialNeighbors.filter((node) => {\n      return myMaze.includes(node);\n    })\n    \n    return myMazeNeighbors;\n    \n  }\n  \n  \n  function isBlockInside(current, elt, depth) {\n    if (!current) {\n      return true;\n    }\n    if (elt.xIndex < depth || elt.yIndex < depth || elt.zIndex < depth) {\n      return false\n    }\n    let inverseDepth = grid.length - depth;\n    if (elt.xIndex > inverseDepth || elt.yIndex > inverseDepth || elt.zIndex > inverseDepth) {\n      return false;\n    }\n    return true;\n    \n    \n  }\n\n\n  let grid = [[[]]];\n  let maze = [];\n  let mazeWalls = [];\n  let inMaze = [];\n  let wallsToCheck = [];\n  let continueDrawing = true;\n  let hasStateProgressed = false;\n  let hasGridBeenMade;\nlet temp;\n  \n  s.setup = function () {\n    s.createCanvas(500/3, 500/3, s.WEBGL);\n    cam = s.createCamera();\n    cam.setPosition(initialOffset * 4, 0, 0)\n    // frameRate(5);\n\n    hasGridBeenMade = false;\n    intervalId = setInterval(() => {\n      stepForward = !stepForward;\n    }, 500)\n\n\n    // // initial maze setup\n    // let startingPoint = grid[0][0][0];\n    // startingPoint.value = true;\n    // inMaze.push(startingPoint);\n\n    // // add neighbors to wallstocheck\n    // grid[0][0][1].previousCube = startingPoint;\n    // grid[0][1][0].previousCube = startingPoint;\n    // grid[1][0][0].previousCube = startingPoint;\n    // wallsToCheck.push(grid[1][0][0]);\n    // wallsToCheck.push(grid[0][1][0]);\n    // wallsToCheck.push(grid[0][0][1]);\n  }\n\n\n  let openSet = []\n  let closedSet = []\n  let continueSearching = true;\n  let current;\n  let goal;\n  let mazeNeighbors;\n  let neighbors;\n  let tempG;\n  let pathMade = false;\n  let finalPath = [];\n  let stepForward = true;\n  let intervalId;\n  let cubeDepth = 0;\n  \n  s.draw = function () {\n\n\n    \n    if (!hasGridBeenMade && s.props.grid.length) {\n      // necessary sets are created once props come in\n      // and starting box is set/placed into open set.\n      // ending box is also determined and placed as the goal node\n      grid = createGrid(s.props.grid);\n      maze = createMaze(s.props.maze, grid);\n      mazeWalls = getWalls(grid, maze);\n      \n      goal = getGoal(grid, maze);\n      \n      let startingPoint = grid[0][0][0]\n      startingPoint.g = 0;\n      startingPoint.f = getDistance(startingPoint, goal);\n      openSet.push(startingPoint)\n      hasGridBeenMade = true;\n    } else {\n      \n      if (stepForward) {\n        stepForward = !stepForward;\n      \n      \n      \n      if (continueSearching && openSet.length) {\n        // search algorighm logic here\n        \n        current = openSet.reduce((a, b) => {\n          return (a.f < b.f ? a : b)\n        });\n        \n        if (current === goal) {\n          continueSearching = false;\n          clearInterval(intervalId);\n        }\n        \n        removeFromArray(openSet, current);\n        closedSet.push(current);\n        \n        // these next 2 functions obtain all of the neighbors of the current\n        // block, and then filters it so it is only the neighbors that are\n        // indeed part of the maze, and are not walls of the maze\n        neighbors = getNeighbors(current);\n        mazeNeighbors = getMazeNeighbors(neighbors, maze);\n        for (let i = 0; i < mazeNeighbors.length; i++) {\n          let neighborNode = mazeNeighbors[i]\n          \n          if (closedSet.includes(neighborNode)) {\n            continue;\n          }\n          \n          tempG = current.g + getDistance(current, neighborNode);\n          \n          if (!openSet.includes(neighborNode)) {\n            openSet.push(neighborNode);\n          } else if (tempG >= neighborNode.g) {\n            continue\n          }\n          \n          neighborNode.previousCube = current;\n          neighborNode.g = tempG;\n          neighborNode.f = neighborNode.g + getDistance(neighborNode, goal);\n          \n          \n        }\n      }\n      \n      \n      \n      \n      // if (openSet.length === 0) {\n      //   continueSearching = false;\n        // clearInterval(intervalId);\n      // }\n      \n    }\n\n      cam.lookAt(0, 0, 0)\n      s.background(225);\n\n      // big cube that encompasses all cubes\n      // fill(0, 0, 0, 20)\n      // box(cubeSize * totalSize + totalSize * cubeOffset);\n\n\n\n      // draw stuff\n      s.translate(-initialOffset, -initialOffset, -initialOffset);\n      s.noStroke();\n      \n      \n      \n      if (current) {\n        cubeDepth = Math.min(current.xIndex, current.yIndex, current.zIndex);\n      }\n      \n      \n      grid.forEach((arr1) => {\n        arr1.forEach((arr2) => {\n          arr2.forEach((el) => {\n\n            if (!isBlockInside(current, el, cubeDepth) && continueSearching) {\n              s.fill(0, 0, 0, 15)\n              el.show()\n            } else {\n              s.fill(0, 0, 0, 150);\n              el.show();\n              // s.fill(0, 0, 245);\n              // el.show();\n            }\n            \n          })\n        })\n      })\n      \n      \n      \n      maze.forEach((cell) => {\n        if (!isBlockInside(current, cell, cubeDepth) && continueSearching) {\n          s.fill(255, 255, 0, 15)\n          cell.show()\n        } else {\n          s.fill(255, 255, 0, 80);\n          cell.show();\n          // s.stroke(0);\n          // s.fill(255, 255, 0, 245);\n          // cell.show();\n          // s.noStroke();\n        }\n        \n        \n        // s.fill(255, 255, 0, 80);\n        // cell.show();\n      })\n\n      wallsToCheck.forEach((cell) => {\n        s.fill(0, 0, 255, 20)\n        cell.show();\n      })\n      \n      \n      \n      openSet.forEach((cell) => {\n        s.fill(0, 255, 0, 20);\n        cell.show();\n      })\n      \n      closedSet.forEach((cell) => {\n        s.fill(255, 0, 0, 20);\n        cell.show();\n      })\n      \n      if (goal) {\n        s.fill(255, 0, 255, 255);\n        goal.show();\n      }\n      \n      //\n      // display external blocks shallowly\n      // as head of search goes further into cube\n      \n      \n      \n      \n      s.stroke(0);\n      s.fill(0, 0, 255, 255);\n      if (current) {\n        current.show();\n      }\n      \n      \n      \n      \n      \n      if (!continueSearching) {\n        temp = current;\n        finalPath.push(temp);\n        while (temp.previousCube && !pathMade) {\n          finalPath.push(temp.previousCube);\n          temp = temp.previousCube;\n        }\n        pathMade = true;\n        finalPath.forEach((item) => {\n          s.noStroke();\n          s.fill(0, 0, 255, 100);\n          item.show()\n        })\n        \n      } else {\n          if (current) {\n          temp = current;\n          let currentPath = [];\n          currentPath.push(temp)\n          while (temp.previousCube) {\n          currentPath.push(temp.previousCube);\n            temp = temp.previousCube\n          }\n          s.fill(0, 0, 255, 255);\n          currentPath.forEach((item) => {\n            item.show();\n          })\n        }\n        \n      }\n      \n      \n    }\n  }\n\n}\n\n\n","import React, { Component } from 'react'\nimport {progressState} from './store'\nimport { connect } from 'react-redux'\n\nimport sketch1 from './sketch1'\nimport sketch2 from './sketch2'\nimport sketch3 from './sketch3'\nimport sketch3top from './sketch3top'\nimport sketch3left from './sketch3left'\nimport sketch3front from './sketch3front'\n\n\nclass P5Wrapper extends Component {\n  \n  \n    componentDidMount() {\n        // this.canvas1 = new window.p5(sketch1, 'canvas1-container')\n        // // this.canvas1.props = this.props.p5Props\n        // // this.canvas1.onSetAppState = this.props.onSetAppState\n\n        // this.canvas2 = new window.p5(sketch2, 'canvas2-container')\n        // this.canvas2.props = this.props.p5Props\n        \n        this.canvas1 = new window.p5(sketch1, 'canvas-container');\n        \n        // pass props like above. and can pass them into\n        // should component update, and on component did update\n        // but i dont need to i believe.\n    }\n\n    shouldComponentUpdate(nextProps) {\n        // this.canvas1.props = nextProps.p5Props\n        // this.canvas2.props = nextProps.p5Props\n        // console.log('=========')\n        // console.log(nextProps.appState);\n        \n        if (nextProps.appState.index === 0) {\n          return true;\n        } else if (nextProps.appState.index === 1) {\n          return true;\n        } else if (nextProps.appState.index === 3) {\n          return true;\n        } else {\n          return false\n        }\n        \n        \n    }\n    \n    componentDidUpdate() {\n      if (this.props.appState.index === 0) {\n        this.canvas1.remove();\n        this.canvas1 = new window.p5(sketch1, 'canvas-container');\n        this.canvas3.remove()\n        this.canvasLeft.remove();\n        this.canvasTop.remove();\n        this.canvasFront.remove();\n        \n      }\n      if (this.props.appState.index === 1) {\n        this.canvas1.remove();\n        this.canvas1 = new window.p5(sketch2, 'canvas-container');\n      }\n\n      if (this.props.appState.index === 3) {\n      this.canvas1.remove();\n        this.canvas3 = new window.p5(sketch3, 'canvas-container')\n        this.canvas3.props = {maze: this.props.maze, grid: this.props.grid}\n        \n        this.canvasLeft = new window.p5(sketch3top, 'top-view')\n        this.canvasLeft.props = {maze: this.props.maze, grid: this.props.grid}\n        \n        this.canvasTop = new window.p5(sketch3left, 'left-view')\n        this.canvasTop.props = {maze: this.props.maze, grid: this.props.grid}\n        \n        this.canvasFront = new window.p5(sketch3front, 'front-view')\n        this.canvasFront.props = {maze: this.props.maze, grid: this.props.grid}\n        \n        \n        \n        \n      }\n    }\n\n    // componentWillUnmount() {\n    //     // this.canvas1.remove()\n    //     // this.canvas2.remove()\n    // }\n    \n    \n\n    render() {\n        \n        \n        return (\n          <div id=\"all-canvases\">\n            <div id=\"left-canvas\">\n              <div id=\"top-view\">\n                \n              </div>\n              <div id=\"left-view\">\n                \n              </div>\n              <div id=\"front-view\">\n                \n              </div>\n            </div>\n            <div id=\"canvas-container\">\n              \n            </div>\n            \n            \n          </div>\n          \n        )\n    }\n}\n\n\nconst mapState = (state) => {\n  return {\n    appState: state.appState,\n    maze: state.maze,\n    grid: state.grid,\n  }\n}\n\nconst mapDispatch = (dispatch) => {\n  return {\n    progressState: () => dispatch(progressState())\n  }\n}\n\n\n\nexport default connect(mapState, mapDispatch)(P5Wrapper);\n","import React from 'react';\nimport { connect } from 'react-redux'\nimport { progressState } from './store'\nimport P5Wrapper from './P5Wrapper'\n\nlet appStates = ['pre-generate', 'generating', 'pre-solve', 'solving', 'done']\nlet buttonTexts = ['Generate Maze', '(Generating)', 'Solve Maze', '(Solving)', 'Restart']\n\nclass HomePage extends React.Component {\n  constructor() {\n    super()\n  }\n\n\n\n\n  render() {\n\n    let buttonText = buttonTexts[this.props.appState.index]\n    let buttonActivation;\n    if (buttonText[0] === '(') {\n      buttonActivation = 'disabled'\n    } else {\n      buttonActivation = ''\n    }\n\n\n\n\n    return (\n      <div>\n\n        <div id=\"button-div\">\n\n          <button type=\"button\" disabled={buttonActivation} onClick={this.props.progressState}>\n            {buttonText}\n          </button>\n\n        </div>\n\n\n        <div id=\"bottom-container\">\n          <div></div>\n          <P5Wrapper id=\"wrapper\"></P5Wrapper>\n          <div id=\"legend\">\n            <h1>Legend</h1>\n            <div id=\"legend-details\">\n            <div>\n              <span className=\"yellow\">&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp; Light-Yellow: Maze passageways\n            </div>\n\n            <div>\n              <span className=\"gray\">&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp; Gray: Maze walls\n            </div>\n\n            <div>\n              <span className=\"purple\">&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp; Purple: Goal\n            </div>\n\n            <div>\n              <span className=\"blue\">&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp; Blue: Current best path\n            </div>\n\n            <div>\n              <span className=\"green\">&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp; Light Green: Nodes next in list to be analyzed\n            </div>\n\n            <div>\n              <span className=\"red\">&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp; Light Red: Nodes already analyzed\n            </div>\n            </div>\n          </div>\n        </div>\n\n\n\n\n      </div>\n    )\n  }\n}\n\n\n\n// const mapState = (state) => {\n//   return {\n//     campuses: state.campuses\n//   }\n// }\n\nconst mapState = (state) => {\n  return {\n    appState: state.appState\n  }\n}\n\nconst mapDispatch = (dispatch) => {\n  return {\n    progressState: () => dispatch(progressState())\n  }\n}\n\n\n\nexport default connect(mapState, mapDispatch)(HomePage);\n","import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nimport HomePage from './HomePage'\n\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <HomePage />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport {Provider} from 'react-redux';\nimport store from './store'\n\nReactDOM.render(\n    <Provider store={store}>\n      <App />\n    </Provider>\n  , document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}